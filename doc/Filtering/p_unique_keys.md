[//]: # (This file is autogenerated)

## p_unique_keys

Returns a partial function that skips elements with repeated keys of an iterable, based on an optional hashing projection.
If no hashing projection is provided, an identity projection is used. In that case, the elements must be stringable.

### Syntax
```php
p_unique_keys(
  [callable(TKey $key]): array-key,]
  [preserveKeys: bool = false,]
)
```

### Examples
Unique keys, based on the identity projection
```php
['a1', 'b1', 'a2', 'b2']
|> p_reindex(fn(string $x) => $x[0]) //= iterable{'a' => 'a1', 'b' => 'b1', 'a' => 'a2', 'b' => 'b2'}
|> p_unique_keys()
//= ['a1', 'b1']
```
```php
['a1', 'b1', 'a2', 'b2']
|> p_reindex(fn(string $x) => $x[0]) //= iterable{'a' => 'a1', 'b' => 'b1', 'a' => 'a2', 'b' => 'b2'}
|> p_unique_keys(preserveKeys: true)
//= ['a' => 'a1', 'b' => 'b1']
```
Unique keys, based on some projection on keys
```php
['a1', 'b1', 'a2', 'b2']
|> p_reindex(fn(string $x) => $x) //= iterable{'a1' => 'a1', 'b1' => 'b1', 'a2' => 'a2', 'b2' => 'b2'}
|> p_unique_keys(fn(string $k) => $k[1])
//= ['a1', 'a2']
```
```php
['a1', 'b1', 'a2', 'b2']
|> p_reindex(fn(string $x) => $x) //= iterable{'a1' => 'a1', 'b1' => 'b1', 'a2' => 'a2', 'b2' => 'b2'}
|> p_unique_keys(fn(string $k) => $k[1])
//= ['a1' => 'a1', 'a2' => 'a2']
```
